import tqdm
import json
import requests

url = "https://api.hyperbolic.xyz/v1/chat/completions"
headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaXZ5cnM5OTlAZ21haWwuY29tIiwiaWF0IjoxNzMyMTg1NzA4fQ.Bn9LTHQo5e-Ke3bMZKA3lr7aMoTQTnb8y_U-rvNxQG8"
}

with open("sol_alpaca_labeled_no_history.json", "r") as f:
    data = json.load(f)
for i in tqdm.tqdm(range(len(data))):
    prompt = {
    "messages": [
        {
            "role": "system",
            "content": """You are master of solidity.Given a large specimen of the smart contract your task is to create a high level human request or human query that should mimic the behaviour of user when they need to build one such smart contract. You are to write only in paragraph and any paragraph cannot exceed 500 words. 
        For Example : 
        For  the specification : The `DefaultSweeper` contract is an implementation of the `AbstractSweeper` contract, designed to facilitate the sweeping of tokens or Ether from the contract's balance to a specified destination address. The contract is initialized with a `controller` address, which is passed to the `AbstractSweeper` constructor. The `sweep` function, which is the primary method of the contract, is marked with the `canSweep` modifier, ensuring that only the controller's authorized caller or owner can invoke it, and that the contract is not in a halted state. The `sweep` function takes two parameters: `_token` (the address of the token to be swept, or `0` for Ether) and `_amount` (the amount to be swept). If `_token` is not `0`, the function checks if the contract has a sufficient balance of the specified token. If so, it transfers the specified amount to the destination address. If `_token` is `0`, the function checks if the contract has a sufficient Ether balance and sends the specified amount to the destination. If the transfer is successful, the function logs the sweep action using the `controller.logSweep` method. The function returns a boolean indicating the success of the operation. To replicate this contract, one must define the `AbstractSweeper` and `Token` contracts, and then deploy the `DefaultSweeper` contract with the address of a valid `controller`.
        
        Response :  Can you create a contract called DefaultSweeper that transfers tokens or Ether from the contract to a specific address? It should allow only authorized users to perform the transfer and check if there’s enough balance before doing so. If it’s a token, it should transfer the specified amount to the given address, and if it’s Ether, it should handle that as well. Make sure it logs the transfer and confirms if it was successful. Also, it should be initialized with a controller address to manage permissions. 
        
        For the specifiction : The `TransferHelper` library in Solidity is designed to provide a set of safe methods for interacting with ERC20 tokens and transferring Ether. The library includes four main functions: `safeApprove`, `safeTransfer`, `safeTransferFrom`, and `safeTransferETH`. Each function is marked as `internal`, meaning they can only be called from within the contract or derived contracts.\n\n1. **`safeApprove(address token, address to, uint256 value)`**: This function allows a contract to approve another address to spend a specified amount of tokens on its behalf. It uses the `call` method to invoke the `approve` function of the ERC20 token contract, encoding the `to` address and `value` with the selector `0x095ea7b3`. The function checks if the call was successful and if the returned data (if any) indicates success, throwing an error if the approval fails.\n\n2. **`safeTransfer(address token, address to, uint256 value)`**: This function transfers a specified amount of tokens from the contract to another address. It uses the `call` method to invoke the `transfer` function of the ERC20 token contract, encoding the `to` address and `value` with the selector `0xa9059cbb`. Similar to `safeApprove`, it checks the success of the call and the returned data, throwing an error if the transfer fails.\n\n3. **`safeTransferFrom(address token, address from, address to, uint256 value)`**: This function transfers a specified amount of tokens from one address to another, using the contract as the intermediary. It uses the `call` method to invoke the `transferFrom` function of the ERC20 token contract, encoding the `from`, `to`, and `value` with the selector `0x23b872dd`. It also checks the success of the call and the returned data, throwing an error if the transfer fails.\n\n4. **`safeTransferETH(address to, uint256 value)`**: This function transfers a specified amount of Ether from the contract to another address. It uses the `call` method with the `value` parameter to send Ether, and checks if the call was successful, throwing an error if the transfer fails.\n\nTo replicate this library, you would need to define a Solidity library with the same name and implement the four functions as described. Each function should use the `call` method to interact with the ERC20 token contract or to send Ether, and include the necessary checks to ensure the operation was successful. The library should be marked with the appropriate Solidity version pragma, such as `pragma solidity 0.7.5;`, and can be included in other contracts using the `import` statement.
        
        Response : Can you create a Solidity library named TransferHelper that provides safe methods for interacting with ERC20 tokens and transferring Ether? The library should include functions like safeApprove for approving token allowances, safeTransfer for sending tokens, safeTransferFrom for transferring tokens from one address to another, and safeTransferETH for sending Ether. Make sure each function uses proper checks to ensure the operation is successful and throws an error if something fails. It should be easy to import and use in other contracts.
        
        For the specification : The `ERC721BurnableUpgradeable` contract is an upgradeable version of the ERC721 token standard, specifically designed to allow tokens to be irreversibly burned (destroyed). This contract inherits from `Initializable`, `ContextUpgradeable`, and `ERC721Upgradeable`, and it includes the following key components:\n\n1. **Initialization Functions**:\n   - `__ERC721Burnable_init()`: This internal function initializes the contract, calling the initialization functions of `ContextUpgradeable` and `ERC165Upgradeable` to set up the context and ERC165 support. It also calls `__ERC721Burnable_init_unchained()`, which is an empty function by default but can be overridden to add additional initialization logic.\n   - `__ERC721Burnable_init_unchained()`: An internal function that is called by `__ERC721Burnable_init()` and is intended to be overridden if additional initialization steps are needed.\n\n2. **Burn Function**:\n   - `burn(uint256 tokenId)`: This public function allows the owner of a token or an approved operator to burn (destroy) a token. It checks if the caller is the owner of the token or an approved operator using `_isApprovedOrOwner(_msgSender(), tokenId)`. If the caller is authorized, it calls the internal `_burn(tokenId)` function to destroy the token.\n\n3. **Gap Storage**:\n   - `uint256[50] private __gap;`: This is a private array used to reserve storage slots for future upgrades. It ensures that the contract can be safely upgraded without overwriting existing storage.\n\n### Steps to Replicate the Contract\n\n1. **Set Up the Development Environment**:\n   - Ensure you have a Solidity compiler installed (version 0.8.0 or higher).\n   - Set up a project using a framework like Hardhat or Truffle.\n\n2. **Import Required Libraries**:\n   - Import the necessary OpenZeppelin contracts and libraries:\n     ```solidity\n     import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\n     import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n     import \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n     import \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n     ```\n\n3. **Define the Contract**:\n   - Create a new contract that inherits from `ERC721BurnableUpgradeable`:\n     ```solidity\n     contract MyERC721Burnable is ERC721BurnableUpgradeable {\n         function initialize(string memory name, string memory symbol) public initializer {\n             __ERC721Burnable_init();\n             __ERC721_init(name, symbol);\n         }\n\n         function burn(uint256 tokenId) public override {\n             require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n             _burn(tokenId);\n         }\n\n         uint256[50] private __gap;\n     }\n     ```\n\n4. **Deploy the Contract**:\n   - Use a deployment script to deploy the contract. For example, with Hardhat:\n     ```javascript\n     const { ethers } = require(\"hardhat\");\n\n     async function main() {\n         const MyERC721Burnable = await ethers.getContractFactory(\"MyERC721Burnable\");\n         const myERC721Burnable = await MyERC721Burnable.deploy();\n         await myERC721Burnable.deployed();\n\n         console.log(\"MyERC721Burnable deployed to:\", myERC721Burnable.address);\n\n         // Initialize the contract\n         await myERC721Burnable.initialize(\"MyToken\", \"MTK\");\n         console.log(\"Contract initialized\");\n     }\n\n     main()\n         .then(() => process.exit(0))\n         .catch((error) => {\n             console.error(error);\n             process.exit(1);\n         });\n     ```\n\n### Method Descriptions\n\n- **`__ERC721Burnable_init()`**:\n  - **Logic**: Initializes the contract by calling the initialization functions of `ContextUpgradeable` and `ERC165Upgradeable`, and then calling `__ERC721Burnable_init_unchained()`.\n  - **How-to**: This function should be called during the contract's initialization process, typically in the `initialize` function of the derived contract.\n\n- **`__ERC721Burnable_init_unchained()`**:\n  - **Logic**: An empty function by default, intended to be overridden if additional initialization steps are needed.\n  - **How-to**: Override this function in the derived contract if you need to perform additional initialization.\n\n- **`burn(uint256 tokenId)`**:\n  - **Logic**: Burns a
        
        Response : Can you create an upgradeable ERC721 contract named ERC721BurnableUpgradeable that allows tokens to be burned irreversibly? The contract should include an initializer function to set up the contract, a burn function to allow the token owner or an approved operator to destroy tokens, and storage gap management for future upgrades. It should inherit from OpenZeppelin’s ERC721Upgradeable and include functionality for upgradeable contracts. Make sure it checks permissions before burning tokens and reserves storage slots to ensure compatibility with future upgrades.
    """
            },
            {
                "role": "user",
                "content": f"""Please generate a Human instruction for the following smart contract specification  : \n {data[i]['input']}"""
            },
            
        ],
        "model": "meta-llama/Llama-3.3-70B-Instruct",
        "max_tokens": 1048,
        "temperature": 0.7,
        "top_p": 0.9
    }
    
    response = requests.post(url, headers=headers, json=prompt)
    data[i]["updated"] = response.json()['choices'][0]['message']['content']
    if i%50 == 0 :
        with open("sol_alpaca_labeled_no_history_upgraded.json", "w") as f:
            json.dump(data, f, indent=4)